<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shiyunlai&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Shiyunlai&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Shiyunlai&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shiyunlai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Shiyunlai&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shiyunlai&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Keep hungry, keep foolish</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-读书笔记-计算机结构与核心概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-03-15T03:43:08.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">笔记-计算机结构与核心概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在<a href="https://www.jianshu.com/p/f9d5b85afe6f" target="_blank" rel="noopener">探索计算机的结构与核心概念</a>一文中从计算机的冯诺伊曼结构开始，简述了如下概念知识：</p>
<ul>
<li>冯诺伊曼计算机结构</li>
<li>现代计算机结构</li>
<li>总线</li>
<li>I/O设备</li>
<li>内存</li>
<li>CPU</li>
<li>寄存器</li>
<li>程序计数器</li>
<li>高速缓冲</li>
<li>DMA：DMA全称为Direct Memory Access直接内存访问,它允许其他硬件可以直接访问内存中的数据,而无需让CPU介入处理.一般会使用到DMA的硬件有显卡、网卡、声卡等.</li>
<li>流水线</li>
<li>超线程</li>
<li>多核</li>
<li>操作系统：操作系统是用于管理计算机硬件与软件的程序,可以把操作系统看成是应用程序与硬件之间插入的一层软件,所有应用程序对硬件的操作尝试都必须通过操作系统.操作系统需要负责管理与配置内存、调度系统资源的优先次序、管理进程与线程、控制I/O设备、操作网络与管理文件系统等事务.可以说操作系统是整个计算机系统中的灵魂所在.</li>
<li>虚拟内存</li>
<li>进程与线程</li>
<li>文件</li>
<li>网络</li>
<li>OSI模型：OSI模型全称为开放式系统互联通信参考模型(Open System Interconnection Reference Model),是由国际标准化组织提出的一个试图使各种计算机在世界范围内进行互联通信的标准框架.</li>
<li>TCP/IP<ul>
<li>三次握手</li>
<li>四次握手</li>
</ul>
</li>
<li>分组交换</li>
<li>数据展示：计算机编程语言拥有多种数据类型, 例如int、char、double等.但不管是什么类型的数据,在计算机中其实都只是一个字节序列(以8位二进制为一个字节).每个机器中对字节序列的排序不大相同,有一些机器按照从最高有效字节到最低有效字节的顺序存储,这种规则被称为大端法;还有一些机器将最低有效字节排在最前面,这种规则被称为小端法.</li>
<li>浮点数</li>
<li>函数调用： 当调用一个函数时,系统会在栈上分配一个空间,存放了函数中的局部变量、函数参数、返回地址等,这样的一个结构被称为栈帧.函数中的数据的存活状态是后进先出的,而栈正好是满足这一特性的数据结构,这也是为什么计算机使用栈来当作函数调用的存储结构.</li>
<li>计算机编程语言</li>
</ul>
<p>如下是一时的思考记录：</p>
<h1 id="‘设计’就是是对‘现实问题’的合理抽象"><a href="#‘设计’就是是对‘现实问题’的合理抽象" class="headerlink" title="‘设计’就是是对‘现实问题’的合理抽象"></a>‘设计’就是是对‘现实问题’的合理抽象</h1><p>看看冯诺伊曼对计算机的抽象：</p>
<p><img src="../img/20200315/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84.png" alt="冯诺伊曼结构"></p>
<p>启发：</p>
<ul>
<li>王东岳的哲学启蒙，此刻看冯诺伊曼的计算机结构原理， 有这么一想：哲学是对人的一个最顶层抽象，抽象结果为： 生，死；哪些追问都围绕着这个结果。</li>
<li>冯诺伊曼对计算机的抽象结果是：输入输出，控制器，运算器，存储器。</li>
<li>而计算机是一种承载人类智力和思考运算的设备，那么这个人类智力的抽象结果是：输入，运算（计算，控制/指令，缓存/存储），输出。</li>
<li>通过阅读，倾听，动手。。。促进抽象能力，提高思考能力。</li>
</ul>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p><img src="../img/20200315/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.webp" alt="虚拟内存"><br>虚拟内存是计算机系统内存管理的一种技术,它为每个进程提供了一个假象,即每个进程都在独占地使用内存(一个连续的地址空间),而实际上,它通常被分割为多个物理内存碎片,还有部分暂时存储在磁盘存储器上,在需要时进行数据交换.使用虚拟内存会使程序的编写更加容易,对真实的物理内存的使用也会更加有效率.</p>
<p>启发：</p>
<ul>
<li>虚拟仓储 —— 应用系统层面每个门店都有一个库存数据，实际上真实的货品、数量、进出都在某个实际的仓库中；</li>
<li>虚拟仓储技术可用作数字化仓储的应用建设中；<br><img src="../img/20200315/%E5%90%AF%E5%8F%91-%E8%99%9A%E6%8B%9F%E4%BB%93%E5%82%A8.png" alt="虚拟仓储"></li>
</ul>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p><img src="../img/20200315/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B-processandthread.svg" alt="进程和线程"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象,它是程序的执行实体,是操作系统对资源进行调度的一个基本单位,同时也是线程的容器.</p>
<p>进程跟虚拟内存一样,也是操作系统提供的一种假象,它让每个程序看上去都是在独占地使用CPU、内存和I/O设备.但其实同一时间只有一个进程在运行,而我们能够边听歌边上网边码代码的原因其实是操作系统在对进程进行切换,一个进程和另一个进程其实是交错执行的,只不过计算机的速度极快,我们无法感受到而已.</p>
<p>操作系统会保持跟踪进程运行所需的所有状态信息,这种状态,被称为上下文(Context),它包含了许多重要的信息,例如程序计数器和寄存器的当前值等.当操作系统需要对当前进程进行切换时(转移到另一个进程),会保存当前进程的上下文,然后恢复新进程的上下文,这时控制权会移交到新进程,新进程会从它上次停下来的地方开始执行,这个过程叫做上下文切换.</p>
<p>操作系统的进程空间可以分为用户空间与内核空间,也就是用户态与内核态.它们的执行权限不同,一般的应用程序是在用户态中运行的,而当应用程序执行系统调用时就需要切换到内核态,由内核执行.</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统所能调度的最小单位,它被包含在进程之中,且一个进程中的所有线程共享进程的资源,一个线程一般被指为进程中的一条单一顺序的控制流.</p>
<p>线程都运行在进程的上下文中,虽然线程共享了进程的资源,但每条线程都拥有自己的独立空间,例如函数调用栈、寄存器、线程本地存储.</p>
<p>线程的实现主要有以下三种方式:</p>
<p>使用内核线程实现: 内核线程就是由操作系统内核直接支持的线程,这种线程由内核来完成线程切换调度,内核通过调度器对线程进行调度,并将线程的任务映射到各个处理器上.应用程序一般不会直接使用内核线程,而是使用内核线程的一个接口: 轻量级进程,每个轻量级进程都由一个内核线程支持,所以它们的关系是1:1的.这种线程的实现方式的缺点也很明显,应用程序想要进行任何线程操作都需要进行系统调用,应用程序会在用户态和内核态之间来回切换,消耗的性能资源较多.</p>
<p>使用用户线程实现: 这种方式将线程完全实现在用户空间中,相关的线程操作都在用户态中完成,这样可以避免切换到内核态,提高了性能.但正因为没有借助系统调用,操作系统只负责对进程分配资源,这些复杂的线程操作与线程调度都需要由用户线程自己处理实现,提高了程序的复杂性.这种实现方式下,一个进程对应多个用户线程,它们是1:N的关系.</p>
<p>混合实现: 这是一种将内核线程与用户线程一起使用的实现方式.在这种实现下,即存在用户线程,也存在轻量级进程.用户线程依旧是在用户空间中建立的(相关的线程操作也都是在用户空间中),但使用了轻量级进程来当作用户线程与内核线程之间的桥梁,让内核线程提供线程调度和对处理器的映射.这种实现方式下,用户线程与轻量级进程的数量比例是不定的,它们是N:M的关系.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" data-id="ck8wqamuj000byurn81nv6y1j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E5%88%B0%E8%80%81/" rel="tag">学到老</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag">计算机原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nodejs-V8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/nodejs-V8/" class="article-date">
  <time datetime="2020-03-13T13:12:36.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/nodejs-V8/">nodejs-V8引擎</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h2><p>V8 JavaScript引擎是Google用于其Chrome浏览器的底层JavaScript引擎。很少有人考虑JavaScript在客户机上实际做了些什么!</p>
<p>实际上，JavaScript引擎负责解释并执行代码。Google使用V8创建了一个用C++编写的超快解释器，该解释器拥有另一个独特特征；您可以下载该引擎并将其嵌入任何应用程序。V8 JavaScript引擎并不仅限于在一个浏览器中运行。</p>
<p>因此，Node实际上会使用Google编写的V8 JavaScript引擎，并将其重建为可在服务器上使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/13/nodejs-V8/" data-id="ck8wqamu60001yurndsic6smx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript%E5%BC%95%E6%93%8E/" rel="tag">JavaScript引擎</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nodejs-事件驱动和非阻塞I-O" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/nodejs-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" class="article-date">
  <time datetime="2020-03-13T00:39:25.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/nodejs-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/">nodejs-事件驱动和非阻塞I/O</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>在我们使用Java，PHP等语言实现编程的时候，我们面向对象编程是完美的编程设计，这使得他们对其他编程方法不屑一顾。却不知大名鼎鼎Node使用的却是事件驱动编程的思想。那什么是事件驱动编程。<br>事件驱动编程，为需要处理的事件编写相应的事件处理程序。代码在事件发生时执行。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         (事件对象)</span><br><span class="line">事件源 ----------------&gt; 事件处理程序（Listener）</span><br></pre></td></tr></table></figure>

<p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p>
<p>  事件源：产生事件的地方(如：html元素，某个定时任务，某次交易过程)</p>
<p>  事件：用户事件，即用户触发的事件，如：点击/鼠标操作/键盘操作等等，系统事件，系统运行过程中产生的事件，如：定时任务/告警/支付后积分变更事件等等</p>
<p>  事件对象：事件发生时，如果需要把事件传递给事件的关注者（listener），则会产生一个事件对象，封装事件的信息，如：发生时间，传递给谁，事件发生的上下文（一些交易数据，便于事件关注者作出处理）</p>
<p>  事件处理程序：也就是事件的监听者（Listener），响应事件的代码 </p>
<blockquote>
<p>事件驱动编程主要思想是通过事件或状态的变化来进行应用程序的流程控制，一般通过事件监听完成，一旦事件被检测到，则调用相应的回调函数。事件驱动主要执行过程是当进来的一个新的请求的时候，请求将会被压入队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。<br>线程驱动是当收到一个请求的时候，将会为该请求开一个新的线程来处理请求。而线程主要是由线程池来管理的。当线程池中有空闲的线程，会从线程池中拿取线程来处理，如果线程池中没有空闲的线程，新来的请求将会进入队列排队，直到线程池中空闲线程<br>原文链接：<a href="https://blog.csdn.net/charlene0824/article/details/51711154" target="_blank" rel="noopener">https://blog.csdn.net/charlene0824/article/details/51711154</a></p>
</blockquote>
<hr>
<p><img src="../img/nodejs/nodejs-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6.webp" alt="事件驱动"></p>
<p>Node通过事件驱动的方式处理请求时无需为每一个请求创建额外的线程。在事件驱动的模型当中，每一个IO工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到堵塞任务时(如：读取文件、查询数据库、调用REST API接口)，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用。</p>
<p>这一套实现开始于Node开始启动的进程，在这个进程中Node会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于堵塞IO的处理在幕后使用线程池来确保工作的执行。Node从池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止堵塞IO占用空闲资源。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。</p>
<p>事件驱动编程，为需要处理的事件编写相应的事件处理程序。代码在事件发生时执行。<br>为需要处理的事件编写相应的事件处理程序。要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能【更加有效地使用cpu】。</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p><img src="../img/nodejs/nodejs-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%9C%BA%E5%88%B6.webp" alt="非阻塞IO"></p>
<ul>
<li>Node是一个单线程的语言，采用事件驱动和异步回调的机制。在执行代码的时候，主线程从上往下依次执行，遇到有需要回调的地方，就将此处加入到事件队列中，然后主线程继续往下走，直到运行结束以后，才去执行事件队列中的回调</li>
<li>node去执行事件队列中的事件时，如果遇到回调，依然是按照顺序添加进入事件队列，主线程一次往下执行，遇到回调就添加，直至执行完毕。</li>
<li>node是一个单线程多进程的。node进程创建一个循环，每个循环就是一个周期，在循环中会从事件队列里查看是否有事件需要处理，如果有就去除事件并执行相关的函数。对于阻塞事件的处理在幕后使用线程池来确保工作的运行，而不占用主循环流程。</li>
</ul>
<p>作者：majunchang<br>链接：<a href="https://www.jianshu.com/p/f891839b27a3" target="_blank" rel="noopener">https://www.jianshu.com/p/f891839b27a3</a><br>来源：简书</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/13/nodejs-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" data-id="ck8wqamu80002yurnb4li3rhf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" rel="tag">事件驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" rel="tag">非阻塞I/O</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nodejs-运行机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-03-12T03:47:22.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/12/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">nodejs的运行机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文内容组成：</p>
<ol>
<li>遇到的问题</li>
<li>方案和原理分析</li>
<li>Demo代码分析</li>
<li>对Node.js优缺点、适用场景分析</li>
</ol>
<p>分析过程中会涉及以下概念：</p>
<ul>
<li><a href="./2020-03-15-nodejs-单线程.md">Node.js是单线程</a></li>
<li><a href="https://nodejs.dev/the-nodejs-event-loop" target="_blank" rel="noopener">执行栈</a></li>
<li><a href="./2020-03-13-nodejs-事件驱动和非阻塞I-O.md">Node.js的事件驱动和非阻塞I/O</a></li>
<li><a href="./2020-03-15-nodejs-EventLoop事件循环.md">EventLoop</a></li>
</ul>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>在使用Node.js开发应用平台时，有个需求：先从数据库查询参数，将其转换为配置定义对象(Definition)，然后存放在内存中，通过一个定义管理器单例(Manager)供其他程序逻辑调用。如：并用于启动子进程。</p>
<p>实现如上需求的编码思路（仅仅给出伪代码做问题讨论）大致如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从数据库查询参数，并转换为定义对象</span></span><br><span class="line">    <span class="keyword">let</span> config = mysql.query(<span class="string">`select * from table where name = <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">let</span> defintion = <span class="keyword">new</span> Definition(config)</span><br><span class="line">    <span class="comment">// 2. 返回加载到的定义</span></span><br><span class="line">    <span class="keyword">return</span> defintion</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 在需要时触发定义加载，如：key='TEST'</span></span><br><span class="line">    <span class="keyword">let</span> def = load(<span class="string">'TEST'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 不符合预期：def为undefined，</span></span><br><span class="line">    <span class="built_in">console</span>.log(def)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码逻辑看上去没问题，但为什么def是undefined？！</p>
<p>百度，看了很多网友博客，才明白这是因为Node.js是<a href="./2020-03-13-nodejs-事件驱动和非阻塞I-O.md">非阻塞</a>的，通过load()方法触发了mysql.query()与数据库交互属于I/O事物，Node.js不会等待执行结束，而是继续执行后续代码，于是第2返回的defintion实际上是undefined。因此3步得到的是undefined。</p>
<p>改进 —— 逻辑上应该等待load拿到定义对象后再save()，也就是需要进行同步处理，可以做如下两点改造：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 改造1: load方法返回Promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从数据库查询参数，并转换为定义对象</span></span><br><span class="line">        <span class="keyword">let</span> config = mysql.query(<span class="string">`select * from table where name = <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">let</span> defintion = <span class="keyword">new</span> Definition(config)</span><br><span class="line">        <span class="comment">// 2. 返回加载到的定义</span></span><br><span class="line">        resolve(defintion)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造2: 在doThing()上使用async/await，以确保load方法能同步拿到加载结果（async/await代码可读性优于Promise/then）才执行后续代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doThing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 3. 在需要时触发定义加载，如：key='TEST'</span></span><br><span class="line">    <span class="keyword">let</span> def = <span class="keyword">await</span> load(<span class="string">'TEST'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 满足预期：def不再为undefined，</span></span><br><span class="line">    <span class="built_in">console</span>.log(def)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Node.js的世界里，不同步的情况还有很多，如：setTimeout、setInterval、文件读写、数据库查询、网络请求http.on(‘connection’,cb)等等</p>
<h1 id="方案和原理介绍"><a href="#方案和原理介绍" class="headerlink" title="方案和原理介绍"></a>方案和原理介绍</h1><p>针对问题以及Node.js的运行原理，看了网上找很多资料，摘抄内容见<a href="./2020-03-31-nodejs-运行机制阅读摘抄.md">《node-运行机制阅读摘抄》</a>，似懂非懂，大体好像明白，但诸多细节不甚明了！</p>
<p>目前脑袋里对Node.js的认知限于——“打开冰箱门，大象放进去，关上冰箱门”！于是看<br><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#the-node-js-event-loop-timers-and-process-nexttick" target="_blank" rel="noopener">Node.js官网资料</a>。试着对Node.js的运行机制做更细微一些的理解！</p>
<p>先借用<a href="https://www.cnblogs.com/peiyu1988/p/8032982.html" target="_blank" rel="noopener">《Nodejs的运行原理-科普篇》</a>一文对Node.js运行机制的比喻</p>
<blockquote>
<p>…NodeJS在寒风中面对着10万并发大军，OK，没问题，上来敌人一个扔到城里，上来一个又扔到城里。城里全民皆兵，可以很好地消化这些敌人…等民兵把敌人打个半死时，NodeJS再一刀斩于马下！</p>
</blockquote>
<p>作者很好的用“敌人来了，扔进城里，打个半死，斩于马下”这个过程比喻Node.js的运行机制！</p>
<h3 id="“敌人”，在Node-js里分两种："><a href="#“敌人”，在Node-js里分两种：" class="headerlink" title="“敌人”，在Node.js里分两种："></a>“敌人”，在Node.js里分两种：</h3><ul>
<li>current operation，也就是非异步操作，由主线程立刻执行的代码；</li>
<li>Blocking， 异步操作，如：文件读取、数据库查询、Timer任务、网络请求等等。</li>
</ul>
<h3 id="“扔到城里”是Node-js对异步任务的分类"><a href="#“扔到城里”是Node-js对异步任务的分类" class="headerlink" title="“扔到城里”是Node.js对异步任务的分类"></a>“扔到城里”是Node.js对异步任务的分类</h3><p>Node.js主线程不会直接处理Blocking类型的代码，而是将其分类到不同的队列，等后台线程处理好了，再执行对应的回调，整个分类过程看起来如下图：</p>
<p><img src="../img/nodejs/Nodejs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B633.png" alt="Node.js任务分类"></p>
<ul>
<li><p>执行node xx.js时，V8解析xx.js代码并放入执行栈；</p>
</li>
<li><p>执行栈和nextTick Queue中的内容会在一次Tick周期内被主线执行 —— 主线程清空执行栈后，立即处理nextTick Queue中的任务。</p>
</li>
<li><p>主线程处理Call Stack和nextTick Queue的过程构成一个完整的Tick周期；</p>
<blockquote>
<p>注意：Call Stack和nextTick Queue不属于EventLoop周期内的队列；</p>
</blockquote>
</li>
<li><p>EventLoop循环中，满足执行条件的回调会被Node.js放回调用栈（变为了current operation），执行栈有内容，则主线程开始一轮新的Tick周期将之处理</p>
<blockquote>
<p>“放回执行栈”这么说并不严谨，但是有助于对下文Node.js运行机制的理解。</p>
</blockquote>
</li>
<li><p>对于Blocing任务Node.js用用了下面几种FIFO的队列来分类：</p>
<ul>
<li><p>Timer Queue</p>
<p>  this phase executes callbacks scheduled by setTimeout() and setInterval().</p>
</li>
<li><p>Pending Callbacks Queue</p>
<p>  executes I/O callbacks deferred to the next loop iteration.</p>
</li>
<li><p>Idle，prepare Queue</p>
<p>  only used internally.</p>
</li>
<li><p>Poll Queue</p>
<p>  retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and setImmediate()); node will block here when appropriate.</p>
</li>
<li><p>Immediate Queue</p>
<p>  setImmediate() callbacks are invoked here.</p>
</li>
<li><p>Close Callbacks Queue</p>
<p>  some close callbacks, e.g. socket.on(‘close’, …).</p>
<blockquote>
<p>注意：上图示意不意味着EventLoop执行时检查队列的顺序，只是用来做任务分类示意。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="“打个半死”表示异步任务已经满足执行条件"><a href="#“打个半死”表示异步任务已经满足执行条件" class="headerlink" title="“打个半死”表示异步任务已经满足执行条件"></a>“打个半死”表示异步任务已经满足执行条件</h3><p>“打”这个动作由Libuv的Thread Pool在后台完成，流程如下图：</p>
<p><img src="../img/nodejs/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.webp" alt="Nodejs运行机制"></p>
<p>工作线程（Work Thread）处理完某个异步任务，会将数据绑定在callback函数上并放回事件队列（Poll Queue）。</p>
<h3 id="“斩于马下”表示Node-js处理了绑定了数据的callback回调函数"><a href="#“斩于马下”表示Node-js处理了绑定了数据的callback回调函数" class="headerlink" title="“斩于马下”表示Node.js处理了绑定了数据的callback回调函数"></a>“斩于马下”表示Node.js处理了绑定了数据的callback回调函数</h3><p>在EventLoop过程中，已完成的异步任务，主线程将开启一次新的Tick周期处理绑定了数据的回调函数。</p>
<h1 id="EventLoop流程"><a href="#EventLoop流程" class="headerlink" title="EventLoop流程"></a>EventLoop流程</h1><p>除了异步I/O任务，还有Timer任务，实时收到的网络请求等待，接下来看下完整一些的EventLoop流程，如下图：</p>
<p><img src="../img/nodejs/nodejs-EventLoop%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="Node EventLoop执行流程"></p>
<ul>
<li>1、执行命令node xx.js开始，V8引擎会将js脚本代码解析并放入执行栈（call stack），Node.js主线程就开始处理代码了，EventLoop开始，同时也开始一个Tick；</li>
<li>2.0、主线程以后进先出的顺序处理执行栈中的代码，Current operation当场处理；</li>
<li>2.1、如果是process.nextTick() 放到nextTick queue，等到执行栈清空后，马上处理；</li>
<li>2.2、如果是I/O异步任务分放到Poll Queue，另外的按照任务分类规则放到对应的队列（线太多，不一一画了）；</li>
<li>2.3、如果执行栈为空则会处理nextTick Queue中的回调，这些代码是主线程同步处理的（所谓的nextTick就是指放在这个时机执行的代码）。当nextTick Queue也被清空，则表示完成一个Tick周期（图中 Tick Start - Tick End）。接着Node.js的EventLoop流程会进入Poll Queue的处理阶段（EventLoop entry poll phase）；</li>
<li>3.0、进入Poll Queue执行阶段，Node.js首先检查poll Queue是否为空；</li>
<li>3.1、不为空，继续检查是否超出最大运行poll循环限制（hard limit：根据操作系统不同的）；</li>
<li>3.2、没超出，则立刻同步方式处理这个回调逻辑（executing callbacks synchronously），注意：执行poll中的回调时，Node.js会将回调函数放到执行栈中，进行一轮新的Tick处理，每个回调一轮Tick；</li>
<li>3.3、结束一轮Tick，解决掉一个poll queue中的回调，回到3.0；</li>
<li>3.4、如果poll queue中的回调次数超过了硬件运行的数量限制，则报错，终止Node.js的Event Loop；<blockquote>
<p>报错信息：RangeError: Maximum call stack size exceeded from v8</p>
</blockquote>
</li>
<li>3.5、如果poll queue中的回调被处理完，也就是Poll Queue为空，这时Node.js会先判断immediate queue是否有内容，有，则进入Check phase。immediate queue中的内容是在此前处理poll queue中任务的各轮Tick中放进来的。</li>
<li>3.6、Node.js进入Check phase，按照先进先出的顺序处理immediate queue中的回调，注意：同样每个回调开一轮新的Tick处理，不过Node.js会连续处理完这个阶段的所有回调函数（待分析清楚）。</li>
<li>3.7、另外一种情况是不存在immediate，Node.js会跳过Check pahase，进而判断当前是否有已经完成的I/O异步任务</li>
<li>3.8、有I/O任务，则等待其执行完成；</li>
<li>3.9、Libuv会将处理完成的I/O任务事件（（回调函数和I/O异步任务获得的数据一起））放回poll queue，这是poll queue不为空，Node.js又按照3.0 - 3.3处理；</li>
<li>3.10、如果没有I/O任务，Node.js会检查是否有已经满足时点的Timer回调任务——指：setInterval、setTimeout。</li>
<li>3.11、没有，则回到poll phase继续等待新I/O任务 —— Libuv线程池处理好的事件，来自网络的I/O事件等等，都会加入到poll queue中。</li>
<li>4.0、如果有到点的Timer回调，Node.js的EventLoop将进入Timer phase，处理Timer Queue中满足执行条件的所有回调函数，同样每个回调一轮新的Tick；</li>
</ul>
<p>至此，脑袋有一个相对清晰的Node.js运行流程模型：Event Loop大圈内套了很多次Tick小圈，这些Tick小圈是Blocking任务满足执行条件时开启的，如果没有满足执行条件的Blocking任务，Node.js将停等待下一个满足执行条件的任务（3.8）！</p>
<h1 id="写代码感受一下EventLoop和Tick"><a href="#写代码感受一下EventLoop和Tick" class="headerlink" title="写代码感受一下EventLoop和Tick"></a>写代码感受一下EventLoop和Tick</h1><p>新建 s3.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0: 启动Node.js，开始了第一轮EventLoop，开始了第一轮Tick'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1: 第一轮Tick时，第一个非阻塞函数（current function）'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2: 第一轮Tick时，第二个非阻塞函数（current function）'</span>)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">'3: 第一轮Tick时，第一个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第一'</span>)&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'13: 第一轮Tick时，第一个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，Node.js新开一轮Tick执行我'</span>)&#125;,<span class="number">10</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'14: 第一轮Tick时，第二个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在13后。'</span>)&#125;,<span class="number">10</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'15: 第一轮Tick时，第三个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在14后'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'16: 输出15步的Tick轮次时加入nextTick，该轮次结束时，输出了我。'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'17: 没有任何Blocking任务，Node.js结束EventLoop，退出Node.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">10</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5: 第一轮Tick时，第四个放入MessageQueue的setTimeout回调函数 虽然是第四个放入MessageQueue的setTimeout，但延时0毫秒，第一轮Tick结束时Node.js检查已满足触发条件，将对应的回调函数放回执行栈，因调用栈非空，Node.js开始了新一轮Tick（第二轮），本输出发生在在第二轮Tick时'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'6: 第二轮Tick时，加入nextTick阶段的回调函数。因为Node.js逐个检查和执行MessageQueue中的Job（处理过程见5），因此第二轮Tick结束时立即执行输出'</span>)&#125;)&#125;,<span class="number">0</span>) </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7: 第一轮Tick时，第五个放入MessageQueue的setTimeout回调函数，虽然也是延时0毫秒，但是按MessageQueu的先进先出原则，Node.js在处理完5后，才检查这个Job，处理过程同5，Node.js又开始轮新一轮Tick（第三轮），本输出发生在第三轮Tick时'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'8: 第三轮Tick时，加入nextTick阶段的回调函数，因此第三轮Tick结束时立即执行输出'</span>)&#125;)&#125;,<span class="number">0</span>) <span class="comment">//FIXME nextTic再加入nextTick呢？本轮，还是下一轮Tick执行</span></span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'xx: 我在可能在13前或16后输出，根据Node.js的处理速度，在10毫秒以内则输出在13前，大于10毫秒则输出在16后，因为这个setTimeout排在MessageQueue最后！'</span>)&#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9: 第一轮Tick时，第一个放在Next new EventLoop start之前的setImmediate回调函数。Node.js经过以上三轮次Tick处理后，发现执行栈为空，且MessageQueue没有满足条件的Job需要处理，准备开始下一轮EventLoop处理。setImmediate的执行时机就在下一轮EventLoop开始前，我又是第一个，Node.js会把回调函数放回执行栈，执行栈非空，Node.js开始新一轮Tick（第四轮），本输出发生在第四轮Tick时'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'10: 第四轮Tick时，加入nextTick阶段的回调函数，因此第四轮Tick结束时立即执行输出'</span>)&#125;) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11: 第一轮Tick时，第二个放在Next new EventLoop start之前的setImmediate回调函数。执行完9，Node.js又开启一轮Tick（第五轮）处理这个setImmediate。本输出发生在第五轮Tick时'</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'12: 第五轮Tick时，加入nextTick阶段的回调函数，因此第五轮Tick结束时立即执行输出'</span>)&#125;) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'xx: 第一轮Tick时，第六个放入MessageQueue的setTimeout回调函数，输出顺序飘忽，但肯定都在nextTick之后。飘忽位置，取决于Node.js执行到第XX轮Tick的耗时是否达到了2毫秒，如果达到，将在当前轮Tick结束时得到执行。例如：第三轮Tick结束时，Node.js的处理耗时已经2毫秒，则我会输出在8后（Node.js开始新一个Tick执行我）'</span>)&#125;,<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">'4: 第一轮Tick时，第二个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第二。第一轮Tick正式结束！'</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>执行命令 node s3.js 看具体结果（根据机器性能会稍有不同）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node s3.js </span></span><br><span class="line">0: 启动Node.js，开始了第一轮EventLoop，开始了第一轮Tick</span><br><span class="line">1: 第一轮Tick时，第一个非阻塞函数（current function）</span><br><span class="line">2: 第一轮Tick时，第二个非阻塞函数（current function）</span><br><span class="line">3: 第一轮Tick时，第一个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第一</span><br><span class="line">4: 第一轮Tick时，第二个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第二。第一轮Tick正式结束！</span><br><span class="line">5: 第一轮Tick时，第四个放入MessageQueue的setTimeout回调函数 虽然是第四个放入MessageQueue的setTimeout，但延时0毫秒，第一轮Tick结束时Node.js检查已满足触发条件，将对应的回调函数放回执行栈，因调用栈非空，Node.js开始了新一轮Tick（第二轮），本输出发生在在第二轮Tick时</span><br><span class="line">6: 第二轮Tick时，加入nextTick阶段的回调函数。因为Node.js逐个检查和执行MessageQueue中的Job（处理过程见5），因此第二轮Tick结束时立即执行输出</span><br><span class="line">7: 第一轮Tick时，第五个放入MessageQueue的setTimeout回调函数，虽然也是延时0毫秒，但是按MessageQueu的先进先出原则，Node.js在处理完5后，才检查这个Job，处理过程同5，Node.js又开始轮新一轮Tick（第三轮），本输出发生在第三轮Tick时</span><br><span class="line">8: 第三轮Tick时，加入nextTick阶段的回调函数，因此第三轮Tick结束时立即执行输出</span><br><span class="line">9: 第一轮Tick时，第一个放在Next new EventLoop start之前的setImmediate回调函数。Node.js经过以上三轮次Tick处理后，发现执行栈为空，且MessageQueue没有满足条件的Job需要处理，准备开始下一轮EventLoop处理。setImmediate的执行时机就在下一轮EventLoop开始前，我又是第一个，Node.js会把回调函数放回执行栈，执行栈非空，Node.js开始新一轮Tick（第四轮），本输出发生在第四轮Tick时</span><br><span class="line">10: 第四轮Tick时，加入nextTick阶段的回调函数，因此第四轮Tick结束时立即执行输出</span><br><span class="line">11: 第一轮Tick时，第二个放在Next new EventLoop start之前的setImmediate回调函数。执行完9，Node.js又开启一轮Tick（第五轮）处理这个setImmediate。本输出发生在第五轮Tick时</span><br><span class="line">12: 第五轮Tick时，加入nextTick阶段的回调函数，因此第五轮Tick结束时立即执行输出</span><br><span class="line">xx: 第一轮Tick时，第六个放入MessageQueue的setTimeout回调函数，输出顺序飘忽，但肯定都在nextTick之后。飘忽位置，取决于Node.js执行到第XX轮Tick的耗时是否达到了2毫秒，如果达到，将在当前轮Tick结束时得到执行。例如：第三轮Tick结束时，Node.js的处理耗时已经2毫秒，则我会输出在8后（Node.js开始新一个Tick执行我）</span><br><span class="line">xx: 我在可能在13前或16后输出，根据Node.js的处理速度，在10毫秒以内则输出在13前，大于10毫秒则输出在16后，因为这个setTimeout排在MessageQueue最后！</span><br><span class="line">13: 第一轮Tick时，第一个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，Node.js新开一轮Tick执行我</span><br><span class="line">14: 第一轮Tick时，第二个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在13后。</span><br><span class="line">15: 第一轮Tick时，第三个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在14后</span><br><span class="line">16: 输出15步的Tick轮次时加入nextTick，该轮次结束时，输出了我。</span><br><span class="line">17: 没有任何Blocking任务，Node.js结束EventLoop，退出Node.js</span><br></pre></td></tr></table></figure>

<p>看完代码运行结果，集中精力看下图中的「Event Loop」，体会一下EventLoop，一轮完整的EventLoop周期是怎么样的！</p>
<p><img src="../img/nodejs/nodejs-EventLoop.webp" alt="Nodejs运行机制"></p>
<h1 id="Node-js方案的优点"><a href="#Node-js方案的优点" class="headerlink" title="Node.js方案的优点"></a>Node.js方案的优点</h1><p>适合高并发场景！</p>
<p>Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。我们来看一个简单的例子，在 Java和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。这个不同的架构承载的并发数量是不一致的。</p>
<p>而Node的出现就是为了解决这个问题：更改连接到服务器的方式。</p>
<p>在Node 声称它不允许使用锁，它不会直接阻塞 I/O 调用。Node在每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。</p>
<h1 id="Node-js方案的缺点"><a href="#Node-js方案的缺点" class="headerlink" title="Node.js方案的缺点"></a>Node.js方案的缺点</h1><p>不适合CPU密集型处理！</p>
<p>如上所述，nodejs的机制是单线程，这个线程里面，有一个事件循环机制，处理所有的请求。在事件处理过程中，它会智能地将一些涉及到IO、网络通信等耗时比较长的操作，交由worker threads去执行，执行完了再回调，这就是所谓的异步IO非阻塞。但是，那些非IO操作，只用CPU计算的操作，它就自己扛了，比如算什么斐波那契数列之类。它是单线程，这些自己扛的任务要一个接着一个地完成，前面那个没完成，后面的只能干等。</p>
<p>因此，对CPU要求比较高的CPU密集型任务多的话，就有可能会造成号称高性能，适合高并发的node.js服务器反应缓慢。</p>
<p>相对而已CPU密集型的场景可以选用Apache——Apache具有多线程高并发共享内存地址空间的特性，那就意味着如果服务器足够强大，处理器足够高核，Apache的运作将会非常良好，所以适用于（并发）异步处理相对较少，后台计算量大，后台业务逻辑复杂的应用程序。</p>
<blockquote>
<p>数据密集型：Data-Intensive applications，数据是其主要挑战（数据量，数据复杂度，数据变化速度），与之相对的是计算密集型，即处理器速度是其瓶颈。现今很多数据都是数据密集型的，而非计算密集型，CPU很少成为瓶颈。<a href="https://www.jianshu.com/p/b83ac0c3032f" target="_blank" rel="noopener">数据密集型应用</a></p>
</blockquote>
<h1 id="适用场景举例"><a href="#适用场景举例" class="headerlink" title="适用场景举例"></a>适用场景举例</h1><p>既然NodeJS处理并发的能力强，但处理计算和逻辑的能力反而很弱，因此，如果我们把复杂的逻辑运算都搬到前端（客户端）完成，而NodeJS只需要提供异步I/O，这样就可以实现对高并发的高性能处理。</p>
<p>这样的场景有很多，比如：</p>
<p>1、RESTful API</p>
<p>这是适合 Node 的理想情况，因为您可以构建它来处理数万条连接。它仍然不需要大量逻辑；它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。完成数据型应用中对数据的获取功能。</p>
<p>2、实时程序</p>
<p>比如聊天服务</p>
<p>聊天应用程序是最能体现 Node.js 优点的例子：轻量级、高流量并且能良好的应对跨平台设备上运行密集型数据（虽然计算能力低）。同时，聊天也是一个非常值得学习的用例，因为它很简单，并且涵盖了目前为止一个典型的 Node.js 会用到的大部分解决方案。</p>
<p>3、单页APP</p>
<p>客户端逻辑强大的单页APP，比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线APP等。<br>ajax很多。现在单页的机制似乎很流行，比如phonegap做出来的APP，一个页面包打天下的例子比比皆是。</p>
<p>总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑（只有一个线程）的场景；</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://nodejs.dev/introduction-to-nodejs" target="_blank" rel="noopener">Introduction to Node.js（官网）</a></p>
<blockquote>
<p>A Node.js app is run in a single process, without creating a new thread for every request. Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.</p>
</blockquote>
</li>
<li><p><a href="https://www.cnblogs.com/peiyu1988/p/8032982.html" target="_blank" rel="noopener">Nodejs的运行原理-科普篇</a></p>
<blockquote>
<p>Node是一个服务器端JavaScript解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。Node是一个可以让JavaScript运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等Core JavaScript没有或者不完善的功能。历史上将JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/12/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" data-id="ck8wqamvc001myurn66331jda" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-博客语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/11/%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2020-03-11T05:32:48.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/11/%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95/">博客语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote>

<h2 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用markdown语法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95/" data-id="ck8wqamtt0000yurncjep62ma" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript%E5%BC%95%E6%93%8E/" rel="tag">JavaScript引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs%E5%8E%9F%E7%90%86/" rel="tag">Nodejs原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" rel="tag">事件驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%88%B0%E8%80%81/" rel="tag">学到老</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" rel="tag">开发技能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B/" rel="tag">数据密集型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" rel="tag">系统架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag">计算机原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E6%91%98%E6%8A%84/" rel="tag">阅读摘抄</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" rel="tag">非阻塞I/O</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript%E5%BC%95%E6%93%8E/" style="font-size: 10px;">JavaScript引擎</a> <a href="/tags/Node-js/" style="font-size: 20px;">Node.js</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Nodejs%E5%8E%9F%E7%90%86/" style="font-size: 15px;">Nodejs原理</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" style="font-size: 10px;">事件驱动</a> <a href="/tags/%E5%AD%A6%E5%88%B0%E8%80%81/" style="font-size: 10px;">学到老</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" style="font-size: 10px;">开发技能</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B/" style="font-size: 10px;">数据密集型</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 10px;">环境搭建</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">系统架构</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机原理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E9%98%85%E8%AF%BB%E6%91%98%E6%8A%84/" style="font-size: 10px;">阅读摘抄</a> <a href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" style="font-size: 10px;">非阻塞I/O</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/31/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E9%98%85%E8%AF%BB%E6%91%98%E6%8A%84/">nodejs-运行机制学习摘抄</a>
          </li>
        
          <li>
            <a href="/2020/03/30/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-docker%E4%B8%8Bzk-kafka/">环境搭建-docker下zookeeper+kafka</a>
          </li>
        
          <li>
            <a href="/2020/03/29/nodejs-%E6%89%A7%E8%A1%8C%E6%A0%88callstack/">nodejs-执行栈callstack</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a>
          </li>
        
          <li>
            <a href="/2020/03/16/nodejs-%E6%91%98%E6%8A%84/">nodejs-摘抄</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Shiyunlai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>