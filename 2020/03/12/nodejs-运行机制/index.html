<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>nodejs的运行机制 | Shiyunlai&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文内容组成：  遇到的问题 方案和原理分析 Demo代码分析 对Node.js优缺点、适用场景分析  分析过程中会涉及以下概念：  Node.js是单线程 执行栈 Node.js的事件驱动和非阻塞I&#x2F;O EventLoop  遇到的问题在使用Node.js开发应用平台时，有个需求：先从数据库查询参数，将其转换为配置定义对象(Definition)，然后存放在内存中，通过一个定义管理器单例(Man">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs的运行机制">
<meta property="og:url" content="http://yoursite.com/2020/03/12/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Shiyunlai&#39;s Blog">
<meta property="og:description" content="本文内容组成：  遇到的问题 方案和原理分析 Demo代码分析 对Node.js优缺点、适用场景分析  分析过程中会涉及以下概念：  Node.js是单线程 执行栈 Node.js的事件驱动和非阻塞I&#x2F;O EventLoop  遇到的问题在使用Node.js开发应用平台时，有个需求：先从数据库查询参数，将其转换为配置定义对象(Definition)，然后存放在内存中，通过一个定义管理器单例(Man">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/03/12/img/nodejs/Nodejs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B633.png">
<meta property="og:image" content="http://yoursite.com/2020/03/12/img/nodejs/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.webp">
<meta property="og:image" content="http://yoursite.com/2020/03/12/img/nodejs/nodejs-EventLoop%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/03/12/img/nodejs/nodejs-EventLoop.webp">
<meta property="article:published_time" content="2020-03-12T03:47:22.000Z">
<meta property="article:modified_time" content="2020-04-12T07:30:09.482Z">
<meta property="article:author" content="Shiyunlai">
<meta property="article:tag" content="Nodejs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/12/img/nodejs/Nodejs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B633.png">
  
    <link rel="alternate" href="/atom.xml" title="Shiyunlai&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shiyunlai&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Keep hungry, keep foolish</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-nodejs-运行机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-03-12T03:47:22.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      nodejs的运行机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文内容组成：</p>
<ol>
<li>遇到的问题</li>
<li>方案和原理分析</li>
<li>Demo代码分析</li>
<li>对Node.js优缺点、适用场景分析</li>
</ol>
<p>分析过程中会涉及以下概念：</p>
<ul>
<li><a href="./2020-03-15-nodejs-单线程.md">Node.js是单线程</a></li>
<li><a href="https://nodejs.dev/the-nodejs-event-loop" target="_blank" rel="noopener">执行栈</a></li>
<li><a href="./2020-03-13-nodejs-事件驱动和非阻塞I-O.md">Node.js的事件驱动和非阻塞I/O</a></li>
<li><a href="./2020-03-15-nodejs-EventLoop事件循环.md">EventLoop</a></li>
</ul>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>在使用Node.js开发应用平台时，有个需求：先从数据库查询参数，将其转换为配置定义对象(Definition)，然后存放在内存中，通过一个定义管理器单例(Manager)供其他程序逻辑调用。如：并用于启动子进程。</p>
<p>实现如上需求的编码思路（仅仅给出伪代码做问题讨论）大致如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从数据库查询参数，并转换为定义对象</span></span><br><span class="line">    <span class="keyword">let</span> config = mysql.query(<span class="string">`select * from table where name = <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">let</span> defintion = <span class="keyword">new</span> Definition(config)</span><br><span class="line">    <span class="comment">// 2. 返回加载到的定义</span></span><br><span class="line">    <span class="keyword">return</span> defintion</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 在需要时触发定义加载，如：key='TEST'</span></span><br><span class="line">    <span class="keyword">let</span> def = load(<span class="string">'TEST'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 不符合预期：def为undefined，</span></span><br><span class="line">    <span class="built_in">console</span>.log(def)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码逻辑看上去没问题，但为什么def是undefined？！</p>
<p>百度，看了很多网友博客，才明白这是因为Node.js是<a href="./2020-03-13-nodejs-事件驱动和非阻塞I-O.md">非阻塞</a>的，通过load()方法触发了mysql.query()与数据库交互属于I/O事物，Node.js不会等待执行结束，而是继续执行后续代码，于是第2返回的defintion实际上是undefined。因此3步得到的是undefined。</p>
<p>改进 —— 逻辑上应该等待load拿到定义对象后再save()，也就是需要进行同步处理，可以做如下两点改造：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 改造1: load方法返回Promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从数据库查询参数，并转换为定义对象</span></span><br><span class="line">        <span class="keyword">let</span> config = mysql.query(<span class="string">`select * from table where name = <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">let</span> defintion = <span class="keyword">new</span> Definition(config)</span><br><span class="line">        <span class="comment">// 2. 返回加载到的定义</span></span><br><span class="line">        resolve(defintion)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造2: 在doThing()上使用async/await，以确保load方法能同步拿到加载结果（async/await代码可读性优于Promise/then）才执行后续代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doThing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 3. 在需要时触发定义加载，如：key='TEST'</span></span><br><span class="line">    <span class="keyword">let</span> def = <span class="keyword">await</span> load(<span class="string">'TEST'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 满足预期：def不再为undefined，</span></span><br><span class="line">    <span class="built_in">console</span>.log(def)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Node.js的世界里，不同步的情况还有很多，如：setTimeout、setInterval、文件读写、数据库查询、网络请求http.on(‘connection’,cb)等等</p>
<h1 id="方案和原理介绍"><a href="#方案和原理介绍" class="headerlink" title="方案和原理介绍"></a>方案和原理介绍</h1><p>针对问题以及Node.js的运行原理，看了网上找很多资料，摘抄内容见<a href="./2020-03-31-nodejs-运行机制阅读摘抄.md">《node-运行机制阅读摘抄》</a>，似懂非懂，大体好像明白，但诸多细节不甚明了！</p>
<p>目前脑袋里对Node.js的认知限于——“打开冰箱门，大象放进去，关上冰箱门”！于是看<br><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#the-node-js-event-loop-timers-and-process-nexttick" target="_blank" rel="noopener">Node.js官网资料</a>。试着对Node.js的运行机制做更细微一些的理解！</p>
<p>先借用<a href="https://www.cnblogs.com/peiyu1988/p/8032982.html" target="_blank" rel="noopener">《Nodejs的运行原理-科普篇》</a>一文对Node.js运行机制的比喻</p>
<blockquote>
<p>…NodeJS在寒风中面对着10万并发大军，OK，没问题，上来敌人一个扔到城里，上来一个又扔到城里。城里全民皆兵，可以很好地消化这些敌人…等民兵把敌人打个半死时，NodeJS再一刀斩于马下！</p>
</blockquote>
<p>作者很好的用“敌人来了，扔进城里，打个半死，斩于马下”这个过程比喻Node.js的运行机制！</p>
<h3 id="“敌人”，在Node-js里分两种："><a href="#“敌人”，在Node-js里分两种：" class="headerlink" title="“敌人”，在Node.js里分两种："></a>“敌人”，在Node.js里分两种：</h3><ul>
<li>current operation，也就是非异步操作，由主线程立刻执行的代码；</li>
<li>Blocking， 异步操作，如：文件读取、数据库查询、Timer任务、网络请求等等。</li>
</ul>
<h3 id="“扔到城里”是Node-js对异步任务的分类"><a href="#“扔到城里”是Node-js对异步任务的分类" class="headerlink" title="“扔到城里”是Node.js对异步任务的分类"></a>“扔到城里”是Node.js对异步任务的分类</h3><p>Node.js主线程不会直接处理Blocking类型的代码，而是将其分类到不同的队列，等后台线程处理好了，再执行对应的回调，整个分类过程看起来如下图：</p>
<p><img src="../img/nodejs/Nodejs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B633.png" alt="Node.js任务分类"></p>
<ul>
<li><p>执行node xx.js时，V8解析xx.js代码并放入执行栈；</p>
</li>
<li><p>执行栈和nextTick Queue中的内容会在一次Tick周期内被主线执行 —— 主线程清空执行栈后，立即处理nextTick Queue中的任务。</p>
</li>
<li><p>主线程处理Call Stack和nextTick Queue的过程构成一个完整的Tick周期；</p>
<blockquote>
<p>注意：Call Stack和nextTick Queue不属于EventLoop周期内的队列；</p>
</blockquote>
</li>
<li><p>EventLoop循环中，满足执行条件的回调会被Node.js放回调用栈（变为了current operation），执行栈有内容，则主线程开始一轮新的Tick周期将之处理</p>
<blockquote>
<p>“放回执行栈”这么说并不严谨，但是有助于对下文Node.js运行机制的理解。</p>
</blockquote>
</li>
<li><p>对于Blocing任务Node.js用用了下面几种FIFO的队列来分类：</p>
<ul>
<li><p>Timer Queue</p>
<p>  this phase executes callbacks scheduled by setTimeout() and setInterval().</p>
</li>
<li><p>Pending Callbacks Queue</p>
<p>  executes I/O callbacks deferred to the next loop iteration.</p>
</li>
<li><p>Idle，prepare Queue</p>
<p>  only used internally.</p>
</li>
<li><p>Poll Queue</p>
<p>  retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and setImmediate()); node will block here when appropriate.</p>
</li>
<li><p>Immediate Queue</p>
<p>  setImmediate() callbacks are invoked here.</p>
</li>
<li><p>Close Callbacks Queue</p>
<p>  some close callbacks, e.g. socket.on(‘close’, …).</p>
<blockquote>
<p>注意：上图示意不意味着EventLoop执行时检查队列的顺序，只是用来做任务分类示意。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="“打个半死”表示异步任务已经满足执行条件"><a href="#“打个半死”表示异步任务已经满足执行条件" class="headerlink" title="“打个半死”表示异步任务已经满足执行条件"></a>“打个半死”表示异步任务已经满足执行条件</h3><p>“打”这个动作由Libuv的Thread Pool在后台完成，流程如下图：</p>
<p><img src="../img/nodejs/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.webp" alt="Nodejs运行机制"></p>
<p>工作线程（Work Thread）处理完某个异步任务，会将数据绑定在callback函数上并放回事件队列（Poll Queue）。</p>
<h3 id="“斩于马下”表示Node-js处理了绑定了数据的callback回调函数"><a href="#“斩于马下”表示Node-js处理了绑定了数据的callback回调函数" class="headerlink" title="“斩于马下”表示Node.js处理了绑定了数据的callback回调函数"></a>“斩于马下”表示Node.js处理了绑定了数据的callback回调函数</h3><p>在EventLoop过程中，已完成的异步任务，主线程将开启一次新的Tick周期处理绑定了数据的回调函数。</p>
<h1 id="EventLoop流程"><a href="#EventLoop流程" class="headerlink" title="EventLoop流程"></a>EventLoop流程</h1><p>除了异步I/O任务，还有Timer任务，实时收到的网络请求等待，接下来看下完整一些的EventLoop流程，如下图：</p>
<p><img src="../img/nodejs/nodejs-EventLoop%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="Node EventLoop执行流程"></p>
<ul>
<li>1、执行命令node xx.js开始，V8引擎会将js脚本代码解析并放入执行栈（call stack），Node.js主线程就开始处理代码了，EventLoop开始，同时也开始一个Tick；</li>
<li>2.0、主线程以后进先出的顺序处理执行栈中的代码，Current operation当场处理；</li>
<li>2.1、如果是process.nextTick() 放到nextTick queue，等到执行栈清空后，马上处理；</li>
<li>2.2、如果是I/O异步任务分放到Poll Queue，另外的按照任务分类规则放到对应的队列（线太多，不一一画了）；</li>
<li>2.3、如果执行栈为空则会处理nextTick Queue中的回调，这些代码是主线程同步处理的（所谓的nextTick就是指放在这个时机执行的代码）。当nextTick Queue也被清空，则表示完成一个Tick周期（图中 Tick Start - Tick End）。接着Node.js的EventLoop流程会进入Poll Queue的处理阶段（EventLoop entry poll phase）；</li>
<li>3.0、进入Poll Queue执行阶段，Node.js首先检查poll Queue是否为空；</li>
<li>3.1、不为空，继续检查是否超出最大运行poll循环限制（hard limit：根据操作系统不同的）；</li>
<li>3.2、没超出，则立刻同步方式处理这个回调逻辑（executing callbacks synchronously），注意：执行poll中的回调时，Node.js会将回调函数放到执行栈中，进行一轮新的Tick处理，每个回调一轮Tick；</li>
<li>3.3、结束一轮Tick，解决掉一个poll queue中的回调，回到3.0；</li>
<li>3.4、如果poll queue中的回调次数超过了硬件运行的数量限制，则报错，终止Node.js的Event Loop；<blockquote>
<p>报错信息：RangeError: Maximum call stack size exceeded from v8</p>
</blockquote>
</li>
<li>3.5、如果poll queue中的回调被处理完，也就是Poll Queue为空，这时Node.js会先判断immediate queue是否有内容，有，则进入Check phase。immediate queue中的内容是在此前处理poll queue中任务的各轮Tick中放进来的。</li>
<li>3.6、Node.js进入Check phase，按照先进先出的顺序处理immediate queue中的回调，注意：同样每个回调开一轮新的Tick处理，不过Node.js会连续处理完这个阶段的所有回调函数（待分析清楚）。</li>
<li>3.7、另外一种情况是不存在immediate，Node.js会跳过Check pahase，进而判断当前是否有已经完成的I/O异步任务</li>
<li>3.8、有I/O任务，则等待其执行完成；</li>
<li>3.9、Libuv会将处理完成的I/O任务事件（（回调函数和I/O异步任务获得的数据一起））放回poll queue，这是poll queue不为空，Node.js又按照3.0 - 3.3处理；</li>
<li>3.10、如果没有I/O任务，Node.js会检查是否有已经满足时点的Timer回调任务——指：setInterval、setTimeout。</li>
<li>3.11、没有，则回到poll phase继续等待新I/O任务 —— Libuv线程池处理好的事件，来自网络的I/O事件等等，都会加入到poll queue中。</li>
<li>4.0、如果有到点的Timer回调，Node.js的EventLoop将进入Timer phase，处理Timer Queue中满足执行条件的所有回调函数，同样每个回调一轮新的Tick；</li>
</ul>
<p>至此，脑袋有一个相对清晰的Node.js运行流程模型：Event Loop大圈内套了很多次Tick小圈，这些Tick小圈是Blocking任务满足执行条件时开启的，如果没有满足执行条件的Blocking任务，Node.js将停等待下一个满足执行条件的任务（3.8）！</p>
<h1 id="写代码感受一下EventLoop和Tick"><a href="#写代码感受一下EventLoop和Tick" class="headerlink" title="写代码感受一下EventLoop和Tick"></a>写代码感受一下EventLoop和Tick</h1><p>新建 s3.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0: 启动Node.js，开始了第一轮EventLoop，开始了第一轮Tick'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1: 第一轮Tick时，第一个非阻塞函数（current function）'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2: 第一轮Tick时，第二个非阻塞函数（current function）'</span>)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">'3: 第一轮Tick时，第一个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第一'</span>)&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'13: 第一轮Tick时，第一个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，Node.js新开一轮Tick执行我'</span>)&#125;,<span class="number">10</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'14: 第一轮Tick时，第二个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在13后。'</span>)&#125;,<span class="number">10</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'15: 第一轮Tick时，第三个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在14后'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'16: 输出15步的Tick轮次时加入nextTick，该轮次结束时，输出了我。'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'17: 没有任何Blocking任务，Node.js结束EventLoop，退出Node.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">10</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5: 第一轮Tick时，第四个放入MessageQueue的setTimeout回调函数 虽然是第四个放入MessageQueue的setTimeout，但延时0毫秒，第一轮Tick结束时Node.js检查已满足触发条件，将对应的回调函数放回执行栈，因调用栈非空，Node.js开始了新一轮Tick（第二轮），本输出发生在在第二轮Tick时'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'6: 第二轮Tick时，加入nextTick阶段的回调函数。因为Node.js逐个检查和执行MessageQueue中的Job（处理过程见5），因此第二轮Tick结束时立即执行输出'</span>)&#125;)&#125;,<span class="number">0</span>) </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7: 第一轮Tick时，第五个放入MessageQueue的setTimeout回调函数，虽然也是延时0毫秒，但是按MessageQueu的先进先出原则，Node.js在处理完5后，才检查这个Job，处理过程同5，Node.js又开始轮新一轮Tick（第三轮），本输出发生在第三轮Tick时'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'8: 第三轮Tick时，加入nextTick阶段的回调函数，因此第三轮Tick结束时立即执行输出'</span>)&#125;)&#125;,<span class="number">0</span>) <span class="comment">//FIXME nextTic再加入nextTick呢？本轮，还是下一轮Tick执行</span></span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'xx: 我在可能在13前或16后输出，根据Node.js的处理速度，在10毫秒以内则输出在13前，大于10毫秒则输出在16后，因为这个setTimeout排在MessageQueue最后！'</span>)&#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9: 第一轮Tick时，第一个放在Next new EventLoop start之前的setImmediate回调函数。Node.js经过以上三轮次Tick处理后，发现执行栈为空，且MessageQueue没有满足条件的Job需要处理，准备开始下一轮EventLoop处理。setImmediate的执行时机就在下一轮EventLoop开始前，我又是第一个，Node.js会把回调函数放回执行栈，执行栈非空，Node.js开始新一轮Tick（第四轮），本输出发生在第四轮Tick时'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'10: 第四轮Tick时，加入nextTick阶段的回调函数，因此第四轮Tick结束时立即执行输出'</span>)&#125;) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11: 第一轮Tick时，第二个放在Next new EventLoop start之前的setImmediate回调函数。执行完9，Node.js又开启一轮Tick（第五轮）处理这个setImmediate。本输出发生在第五轮Tick时'</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'12: 第五轮Tick时，加入nextTick阶段的回调函数，因此第五轮Tick结束时立即执行输出'</span>)&#125;) </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'xx: 第一轮Tick时，第六个放入MessageQueue的setTimeout回调函数，输出顺序飘忽，但肯定都在nextTick之后。飘忽位置，取决于Node.js执行到第XX轮Tick的耗时是否达到了2毫秒，如果达到，将在当前轮Tick结束时得到执行。例如：第三轮Tick结束时，Node.js的处理耗时已经2毫秒，则我会输出在8后（Node.js开始新一个Tick执行我）'</span>)&#125;,<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">'4: 第一轮Tick时，第二个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第二。第一轮Tick正式结束！'</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>执行命令 node s3.js 看具体结果（根据机器性能会稍有不同）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node s3.js </span></span><br><span class="line">0: 启动Node.js，开始了第一轮EventLoop，开始了第一轮Tick</span><br><span class="line">1: 第一轮Tick时，第一个非阻塞函数（current function）</span><br><span class="line">2: 第一轮Tick时，第二个非阻塞函数（current function）</span><br><span class="line">3: 第一轮Tick时，第一个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第一</span><br><span class="line">4: 第一轮Tick时，第二个放到nextTick阶段的回调函数。执行栈已空时执行，在nextTick中排序第二。第一轮Tick正式结束！</span><br><span class="line">5: 第一轮Tick时，第四个放入MessageQueue的setTimeout回调函数 虽然是第四个放入MessageQueue的setTimeout，但延时0毫秒，第一轮Tick结束时Node.js检查已满足触发条件，将对应的回调函数放回执行栈，因调用栈非空，Node.js开始了新一轮Tick（第二轮），本输出发生在在第二轮Tick时</span><br><span class="line">6: 第二轮Tick时，加入nextTick阶段的回调函数。因为Node.js逐个检查和执行MessageQueue中的Job（处理过程见5），因此第二轮Tick结束时立即执行输出</span><br><span class="line">7: 第一轮Tick时，第五个放入MessageQueue的setTimeout回调函数，虽然也是延时0毫秒，但是按MessageQueu的先进先出原则，Node.js在处理完5后，才检查这个Job，处理过程同5，Node.js又开始轮新一轮Tick（第三轮），本输出发生在第三轮Tick时</span><br><span class="line">8: 第三轮Tick时，加入nextTick阶段的回调函数，因此第三轮Tick结束时立即执行输出</span><br><span class="line">9: 第一轮Tick时，第一个放在Next new EventLoop start之前的setImmediate回调函数。Node.js经过以上三轮次Tick处理后，发现执行栈为空，且MessageQueue没有满足条件的Job需要处理，准备开始下一轮EventLoop处理。setImmediate的执行时机就在下一轮EventLoop开始前，我又是第一个，Node.js会把回调函数放回执行栈，执行栈非空，Node.js开始新一轮Tick（第四轮），本输出发生在第四轮Tick时</span><br><span class="line">10: 第四轮Tick时，加入nextTick阶段的回调函数，因此第四轮Tick结束时立即执行输出</span><br><span class="line">11: 第一轮Tick时，第二个放在Next new EventLoop start之前的setImmediate回调函数。执行完9，Node.js又开启一轮Tick（第五轮）处理这个setImmediate。本输出发生在第五轮Tick时</span><br><span class="line">12: 第五轮Tick时，加入nextTick阶段的回调函数，因此第五轮Tick结束时立即执行输出</span><br><span class="line">xx: 第一轮Tick时，第六个放入MessageQueue的setTimeout回调函数，输出顺序飘忽，但肯定都在nextTick之后。飘忽位置，取决于Node.js执行到第XX轮Tick的耗时是否达到了2毫秒，如果达到，将在当前轮Tick结束时得到执行。例如：第三轮Tick结束时，Node.js的处理耗时已经2毫秒，则我会输出在8后（Node.js开始新一个Tick执行我）</span><br><span class="line">xx: 我在可能在13前或16后输出，根据Node.js的处理速度，在10毫秒以内则输出在13前，大于10毫秒则输出在16后，因为这个setTimeout排在MessageQueue最后！</span><br><span class="line">13: 第一轮Tick时，第一个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，Node.js新开一轮Tick执行我</span><br><span class="line">14: 第一轮Tick时，第二个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在13后。</span><br><span class="line">15: 第一轮Tick时，第三个放入MessageQueue的setTimeout回调函数 延时10毫秒。终于到10毫秒了，但是在MessageQueue中我排在14后</span><br><span class="line">16: 输出15步的Tick轮次时加入nextTick，该轮次结束时，输出了我。</span><br><span class="line">17: 没有任何Blocking任务，Node.js结束EventLoop，退出Node.js</span><br></pre></td></tr></table></figure>

<p>看完代码运行结果，集中精力看下图中的「Event Loop」，体会一下EventLoop，一轮完整的EventLoop周期是怎么样的！</p>
<p><img src="../img/nodejs/nodejs-EventLoop.webp" alt="Nodejs运行机制"></p>
<h1 id="Node-js方案的优点"><a href="#Node-js方案的优点" class="headerlink" title="Node.js方案的优点"></a>Node.js方案的优点</h1><p>适合高并发场景！</p>
<p>Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。我们来看一个简单的例子，在 Java和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。这个不同的架构承载的并发数量是不一致的。</p>
<p>而Node的出现就是为了解决这个问题：更改连接到服务器的方式。</p>
<p>在Node 声称它不允许使用锁，它不会直接阻塞 I/O 调用。Node在每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。</p>
<h1 id="Node-js方案的缺点"><a href="#Node-js方案的缺点" class="headerlink" title="Node.js方案的缺点"></a>Node.js方案的缺点</h1><p>不适合CPU密集型处理！</p>
<p>如上所述，nodejs的机制是单线程，这个线程里面，有一个事件循环机制，处理所有的请求。在事件处理过程中，它会智能地将一些涉及到IO、网络通信等耗时比较长的操作，交由worker threads去执行，执行完了再回调，这就是所谓的异步IO非阻塞。但是，那些非IO操作，只用CPU计算的操作，它就自己扛了，比如算什么斐波那契数列之类。它是单线程，这些自己扛的任务要一个接着一个地完成，前面那个没完成，后面的只能干等。</p>
<p>因此，对CPU要求比较高的CPU密集型任务多的话，就有可能会造成号称高性能，适合高并发的node.js服务器反应缓慢。</p>
<p>相对而已CPU密集型的场景可以选用Apache——Apache具有多线程高并发共享内存地址空间的特性，那就意味着如果服务器足够强大，处理器足够高核，Apache的运作将会非常良好，所以适用于（并发）异步处理相对较少，后台计算量大，后台业务逻辑复杂的应用程序。</p>
<blockquote>
<p>数据密集型：Data-Intensive applications，数据是其主要挑战（数据量，数据复杂度，数据变化速度），与之相对的是计算密集型，即处理器速度是其瓶颈。现今很多数据都是数据密集型的，而非计算密集型，CPU很少成为瓶颈。<a href="https://www.jianshu.com/p/b83ac0c3032f" target="_blank" rel="noopener">数据密集型应用</a></p>
</blockquote>
<h1 id="适用场景举例"><a href="#适用场景举例" class="headerlink" title="适用场景举例"></a>适用场景举例</h1><p>既然NodeJS处理并发的能力强，但处理计算和逻辑的能力反而很弱，因此，如果我们把复杂的逻辑运算都搬到前端（客户端）完成，而NodeJS只需要提供异步I/O，这样就可以实现对高并发的高性能处理。</p>
<p>这样的场景有很多，比如：</p>
<p>1、RESTful API</p>
<p>这是适合 Node 的理想情况，因为您可以构建它来处理数万条连接。它仍然不需要大量逻辑；它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。完成数据型应用中对数据的获取功能。</p>
<p>2、实时程序</p>
<p>比如聊天服务</p>
<p>聊天应用程序是最能体现 Node.js 优点的例子：轻量级、高流量并且能良好的应对跨平台设备上运行密集型数据（虽然计算能力低）。同时，聊天也是一个非常值得学习的用例，因为它很简单，并且涵盖了目前为止一个典型的 Node.js 会用到的大部分解决方案。</p>
<p>3、单页APP</p>
<p>客户端逻辑强大的单页APP，比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线APP等。<br>ajax很多。现在单页的机制似乎很流行，比如phonegap做出来的APP，一个页面包打天下的例子比比皆是。</p>
<p>总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑（只有一个线程）的场景；</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://nodejs.dev/introduction-to-nodejs" target="_blank" rel="noopener">Introduction to Node.js（官网）</a></p>
<blockquote>
<p>A Node.js app is run in a single process, without creating a new thread for every request. Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.</p>
</blockquote>
</li>
<li><p><a href="https://www.cnblogs.com/peiyu1988/p/8032982.html" target="_blank" rel="noopener">Nodejs的运行原理-科普篇</a></p>
<blockquote>
<p>Node是一个服务器端JavaScript解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。Node是一个可以让JavaScript运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等Core JavaScript没有或者不完善的功能。历史上将JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/12/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" data-id="ck8wqamvc001myurn66331jda" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/13/nodejs-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          nodejs-事件驱动和非阻塞I/O
        
      </div>
    </a>
  
  
    <a href="/2020/03/11/%E5%8D%9A%E5%AE%A2%E8%AF%AD%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">博客语法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript%E5%BC%95%E6%93%8E/" rel="tag">JavaScript引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs%E5%8E%9F%E7%90%86/" rel="tag">Nodejs原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" rel="tag">事件驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%88%B0%E8%80%81/" rel="tag">学到老</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" rel="tag">开发技能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B/" rel="tag">数据密集型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" rel="tag">系统架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" rel="tag">计算机原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E6%91%98%E6%8A%84/" rel="tag">阅读摘抄</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" rel="tag">非阻塞I/O</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript%E5%BC%95%E6%93%8E/" style="font-size: 10px;">JavaScript引擎</a> <a href="/tags/Node-js/" style="font-size: 20px;">Node.js</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/Nodejs%E5%8E%9F%E7%90%86/" style="font-size: 15px;">Nodejs原理</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" style="font-size: 10px;">事件驱动</a> <a href="/tags/%E5%AD%A6%E5%88%B0%E8%80%81/" style="font-size: 10px;">学到老</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" style="font-size: 10px;">开发技能</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B/" style="font-size: 10px;">数据密集型</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 10px;">环境搭建</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">系统架构</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机原理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E9%98%85%E8%AF%BB%E6%91%98%E6%8A%84/" style="font-size: 10px;">阅读摘抄</a> <a href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9EI-O/" style="font-size: 10px;">非阻塞I/O</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/31/nodejs-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E9%98%85%E8%AF%BB%E6%91%98%E6%8A%84/">nodejs-运行机制学习摘抄</a>
          </li>
        
          <li>
            <a href="/2020/03/30/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-docker%E4%B8%8Bzk-kafka/">环境搭建-docker下zookeeper+kafka</a>
          </li>
        
          <li>
            <a href="/2020/03/29/nodejs-%E6%89%A7%E8%A1%8C%E6%A0%88callstack/">nodejs-执行栈callstack</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">进程线程</a>
          </li>
        
          <li>
            <a href="/2020/03/16/nodejs-%E6%91%98%E6%8A%84/">nodejs-摘抄</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Shiyunlai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>